<script>
    interface NominatimResult { display_name: string; lat: string; lon: string; }
    interface RoutingResultEvent { routes: Array<{ summary: { totalDistance: number; totalTime: number } }>; }
    interface RoutingControl extends L.Control { on(type: string, fn: (event: RoutingResultEvent) => void): this; }

    var map: L.Map | null = null
    var routingControl: RoutingControl | null = null

    function assertError(err: unknown, name: string) {
        err = `${name} Error: ${err}`
        alert(err)
        console.error(err)
    }
    window.assertError = assertError

    GetMap()
    function GetMap() {
        if (document.getElementById('myMap') && typeof window.L !== 'undefined') {
            // Default location (Bay Area)
            var defaultLocation: [number, number] = [37.7749, -122.4194];
            var initialZoom = 10;
            var mapCenter: [number, number] = defaultLocation;

            // Request user's location first
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        // Got user location, use it
                        mapCenter = [position.coords.latitude, position.coords.longitude] as [number, number];
                        initialZoom = 12;
                        initializeMap();
                    },
                    error => {
                        console.warn('Geolocation error:', error.message);
                        // Geolocation failed, use default location
                        initializeMap();
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    }
                );
            } else {
                console.warn('Geolocation is not supported by this browser');
                // Geolocation not supported, use default location
                initializeMap();
            }

            function initializeMap() {
                // Initialize Leaflet map
                map = window.L.map('myMap').setView(mapCenter, initialZoom);

                // Add Wikimedia maps tile layer (clean, regular style, no highway exits)
                window.L.tileLayer('https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}{r}.png', {
                    attribution: '<a href="https://wikimediafoundation.org/wiki/Maps_Terms_of_Use">Wikimedia</a>',
                    maxZoom: 19
                }).addTo(map!);

                if (window.onMapLoad) window.onMapLoad(map!)
            }
        }
        else {
            window.addEventListener('DOMContentLoaded', GetMap)
        }
    }

    var stopsArea = document.querySelector('.stops-area')
    var stops = stopsArea?.querySelector('.stops')
    var closeButtons = document.querySelectorAll('.close')
    var goBtn = document.querySelector('.calc-route')

    var directionsElement = document.querySelector('#directions')

    async function geocodeAddress(address: string) {
        // Use Nominatim (OpenStreetMap) geocoding service
        var url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;
        try {
            var response = await fetch(url);
            var data = await response.json();
            if (data && data.length > 0) {
                return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
            }
        } catch (error) {
            console.error('Geocoding error:', error);
        }
        return null;
    }

    async function addDirections(_e: Event) {
        var places: string[] = []

        stops?.querySelectorAll('.stop').forEach(s => {
            if (s.getAttribute('final-value')) {
                places.push(s.getAttribute('final-value')!)
            }
        })

        if (places.length < 2) {
            alert('Please add at least 2 stops');
            return;
        }

        // Remove existing routing control if any
        if (routingControl) {
            map?.removeControl(routingControl);
        }

        // Geocode all places
        var waypoints = [];
        for (var i = 0; i < places.length; i++) {
            var coords = await geocodeAddress(places[i]);
            if (coords) {
                waypoints.push(window.L.latLng(coords.lat, coords.lng));
            } else {
                alert('Could not geocode: ' + places[i]);
                return;
            }
        }

        // Create routing control with waypoints
        if (typeof window.L.Routing !== 'undefined') {
            routingControl = (window.L.Routing.control({
                waypoints: waypoints,
                routeWhileDragging: false,
                showAlternatives: false,
                fitSelectedRoutes: true,
                lineOptions: {
                    styles: [{color: '#6FA1EC', weight: 4}],
                    extendToWaypoints: true,
                    missingRouteTolerance: 0
                }
            }).addTo(map!) as unknown) as RoutingControl;

            // Display route in the directions element
            routingControl.on('routesfound', (e: RoutingResultEvent) => {
                var routes = e.routes;
                var summary = routes[0].summary;
                directionsElement && (directionsElement.innerHTML = '<div class="route-summary">' +
                    '<h3>Route Summary</h3>' +
                    '<p>Total Distance: ' + (summary.totalDistance / 1609.34).toFixed(2) + ' miles</p>' +
                    '<p>Estimated Time: ' + Math.round(summary.totalTime / 60) + ' minutes</p>' +
                    '</div>');
            });
        } else {
            alert('Routing library not loaded. Please refresh the page.');
        }
    }

    document.querySelector('.add-stop')?.addEventListener('click', _e => {
        var stopsAmt = stops?.querySelectorAll('.stop').length ?? 0

        var stopContainer = document.createElement('div')
        stopContainer.classList.add('stop-container')

        var stopParent = document.createElement('div')
        stopParent.classList.add('stop-parent')

        var stop = document.createElement('input')
        stop.classList.add('stop')
        stop.placeholder = `Stop #${stopsAmt+1}`
        stop.title = `Stop #${stopsAmt+1}`
        stop.addEventListener('keypress', e => {
            stopChange(e as Event, stopsAmt-1)
        })
        stopParent.appendChild(stop)

        var closeButton = document.createElement('button')
        closeButton.classList.add('close')
        closeButton.classList.add('removeStyles')
        closeButton.onclick = e => {
            onCloseClick(e)
        }

        var closeIcon = document.createElement('svg')
        closeIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
        closeIcon.setAttribute('viewBox', '0 -960 960 960')

        var closePath = document.createElement('path')
        closePath.setAttribute('d', 'm256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z')
        closeIcon.appendChild(closePath)

        closeButton.appendChild(closeIcon)

        stopParent.appendChild(closeButton)
        stopContainer.appendChild(stopParent)

        var options = document.createElement('div')
        options.classList.add('options')
        stopContainer.appendChild(options)

        stops?.appendChild(stopContainer)
    })

    closeButtons.forEach(b => {
        (b as HTMLButtonElement).onclick = (e: Event) => onCloseClick(e)
    })

    function onCloseClick(e: Event) {
        ((e.target as HTMLElement)?.parentNode?.parentNode?.parentNode as HTMLElement)?.remove();
        reorderStops()
    }

    function reorderStops() {
        stops?.querySelectorAll('.stop').forEach((s, i) => {
            (s as HTMLInputElement).placeholder = `Stop #${i+1}`
        })
    }

    stops?.querySelectorAll('.stop').forEach((s, i) => {
        (s as HTMLInputElement).onchange = e => {
            stopChange(e, i)
        }
    })

    async function stopChange(e: Event, i: number) {
        var finalValue = (e.target as HTMLInputElement).getAttribute('final-value')
        var searchText = (e.target as HTMLInputElement).value

        var optionsEle = stops?.querySelectorAll('.options')[i]

        optionsEle?.querySelectorAll('.option').forEach(o => {
            o.remove()
        })

        if (finalValue !== searchText && searchText.length > 2) {
            // Use Nominatim geocoding service for search
            var url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchText)}&limit=5`;

            try {
                var response = await fetch(url);
                var results: NominatimResult[] = await response.json();

                results.forEach(r => {
                    createOption(r.display_name, i, optionsEle);
                });

                function createOption(content: string, i: number, optionsEle: Element | undefined, lastLoc=false) {
                    var aEle = document.createElement('button')
                    aEle.classList.add('option')
                    aEle.classList.add('removeStyles')
                    aEle.textContent = content
                    if (lastLoc) {
                        aEle.classList.add('lastLoc')
                        aEle.disabled = true
                    }
                    else {
                        aEle.onclick = e => selectOption(e, i)
                    }
                    optionsEle?.appendChild(aEle)
                }
            } catch (error) {
                console.error('Geocoding search error:', error);
            }
        }
    }

    function selectOption(e: MouseEvent, i: number) {
        var place = (e.target as HTMLElement).textContent ?? ''
        var optionsEle = stops?.querySelectorAll('.options')[i]

        optionsEle?.querySelectorAll('.option').forEach(o => {
            o.remove()
        })

        var stop: HTMLInputElement = stops?.querySelectorAll('.stop')[i] as HTMLInputElement
        stop.setAttribute('final-value', place)
        stop.value = place
    }

    goBtn?.addEventListener('click', addDirections)
</script>
